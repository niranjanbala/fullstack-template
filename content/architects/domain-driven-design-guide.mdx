---
title: "Domain-Driven Design (DDD) for Enterprise Architecture"
description: "Master Domain-Driven Design principles to build maintainable, scalable enterprise systems. Learn strategic design, tactical patterns, and implementation strategies for complex business domains."
category: "architects"
tags: ["domain-driven-design", "enterprise-architecture", "strategic-design", "tactical-patterns", "ubiquitous-language", "bounded-contexts", "aggregates"]
publishedAt: "2024-01-15"
difficulty: "advanced"
externalLinks:
  - title: "Domain-Driven Design by Eric Evans"
    url: "https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215"
    description: "The foundational book on Domain-Driven Design"
    category: "books"
  - title: "Implementing Domain-Driven Design by Vaughn Vernon"
    url: "https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577"
    description: "Practical implementation guide for DDD"
    category: "books"
  - title: "Microsoft DDD Documentation"
    url: "https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/"
    description: "Microsoft's guide to DDD in microservices"
    category: "documentation"
  - title: "DDD Community"
    url: "https://dddcommunity.org/"
    description: "Community resources and discussions on DDD"
    category: "community"
  - title: "EventStorming"
    url: "https://www.eventstorming.com/"
    description: "Workshop format for exploring complex business domains"
    category: "tools"
relatedGuides: ["cqrs-event-sourcing-guide", "microservices-architecture-guide", "api-design-patterns-guide"]
---

# Domain-Driven Design for Enterprise Architecture

Build maintainable, scalable enterprise systems by aligning software design with business complexity. Master strategic design patterns, tactical implementations, and collaborative modeling techniques that enable teams to tackle complex business domains effectively.

## Introduction

Domain-Driven Design (DDD) is a software development approach that focuses on creating a shared understanding of complex business domains. This guide covers:

- **Strategic Design**: Bounded contexts, context mapping, and domain modeling
- **Tactical Patterns**: Aggregates, entities, value objects, and domain services
- **Implementation Strategies**: Layered architecture, hexagonal architecture, and event-driven design
- **Collaborative Modeling**: Event storming, domain storytelling, and ubiquitous language

<Callout type="info">
Organizations implementing DDD report 40% faster feature delivery, 60% reduction in bugs, and 50% improvement in team communication around complex business requirements.
</Callout>

## Strategic Design Patterns

### Bounded Contexts

Define clear boundaries around related business capabilities:

```typescript
// E-commerce domain with multiple bounded contexts

// Sales Context
namespace Sales {
  export interface Customer {
    customerId: CustomerId;
    name: CustomerName;
    creditLimit: Money;
    preferredPaymentMethod: PaymentMethod;
  }

  export class Order {
    constructor(
      private orderId: OrderId,
      private customerId: CustomerId,
      private items: OrderItem[],
      private shippingAddress: Address
    ) {}

    public calculateTotal(): Money {
      return this.items.reduce(
        (total, item) => total.add(item.getSubtotal()),
        Money.zero()
      );
    }

    public canBeShipped(): boolean {
      return this.items.every(item => item.isInStock());
    }
  }
}

// Inventory Context
namespace Inventory {
  export interface Product {
    productId: ProductId;
    sku: SKU;
    stockLevel: Quantity;
    reorderPoint: Quantity;
    supplier: SupplierId;
  }

  export class InventoryService {
    public reserveStock(productId: ProductId, quantity: Quantity): Promise<ReservationId> {
      // Implementation for stock reservation
    }

    public releaseReservation(reservationId: ReservationId): Promise<void> {
      // Implementation for releasing stock reservation
    }
  }
}

// Shipping Context
namespace Shipping {
  export interface Shipment {
    shipmentId: ShipmentId;
    orderId: OrderId; // Reference to Sales context
    trackingNumber: TrackingNumber;
    carrier: Carrier;
    estimatedDelivery: Date;
  }

  export class ShippingService {
    public createShipment(
      orderId: OrderId,
      shippingAddress: Address,
      items: ShippableItem[]
    ): Promise<Shipment> {
      // Implementation for creating shipments
    }
  }
}
```

### Context Mapping

Define relationships between bounded contexts:

```typescript
// Context Map for E-commerce System

interface ContextMap {
  contexts: BoundedContext[];
  relationships: ContextRelationship[];
}

type RelationshipType = 
  | 'SharedKernel'
  | 'CustomerSupplier'
  | 'Conformist'
  | 'AnticorruptionLayer'
  | 'PartnershipSeparateWays';

interface ContextRelationship {
  upstream: BoundedContext;
  downstream: BoundedContext;
  type: RelationshipType;
  integrationPattern: IntegrationPattern;
}

// Example: Sales Context integrates with Payment Context
const salesPaymentIntegration: ContextRelationship = {
  upstream: 'PaymentContext',
  downstream: 'SalesContext',
  type: 'CustomerSupplier',
  integrationPattern: {
    type: 'API',
    protocol: 'REST',
    dataFormat: 'JSON',
    errorHandling: 'CircuitBreaker'
  }
};

// Anti-corruption Layer for legacy system integration
class LegacyOrderSystemAdapter {
  constructor(private legacyApi: LegacyOrderAPI) {}

  public async translateOrder(domainOrder: Sales.Order): Promise<LegacyOrder> {
    return {
      orderNumber: domainOrder.orderId.value,
      customerCode: await this.getCustomerCode(domainOrder.customerId),
      lineItems: domainOrder.items.map(item => ({
        partNumber: item.productId.value,
        quantity: item.quantity.value,
        unitPrice: item.unitPrice.amount
      })),
      totalAmount: domainOrder.calculateTotal().amount
    };
  }

  private async getCustomerCode(customerId: CustomerId): Promise<string> {
    // Translate domain customer ID to legacy customer code
    const legacyCustomer = await this.legacyApi.getCustomer(customerId.value);
    return legacyCustomer.customerCode;
  }
}
```

### Ubiquitous Language

Establish shared terminology across the team:

```typescript
// Order Management Domain - Ubiquitous Language Implementation

// Value Objects with domain-specific behavior
class Money {
  constructor(
    private readonly amount: number,
    private readonly currency: Currency
  ) {
    if (amount < 0) {
      throw new Error('Money amount cannot be negative');
    }
  }

  public add(other: Money): Money {
    this.ensureSameCurrency(other);
    return new Money(this.amount + other.amount, this.currency);
  }

  public isGreaterThan(other: Money): boolean {
    this.ensureSameCurrency(other);
    return this.amount > other.amount;
  }

  private ensureSameCurrency(other: Money): void {
    if (this.currency !== other.currency) {
      throw new Error('Cannot operate on different currencies');
    }
  }
}

// Domain-specific terminology
class OrderStatus {
  static readonly PENDING = new OrderStatus('PENDING');
  static readonly CONFIRMED = new OrderStatus('CONFIRMED');
  static readonly SHIPPED = new OrderStatus('SHIPPED');
  static readonly DELIVERED = new OrderStatus('DELIVERED');
  static readonly CANCELLED = new OrderStatus('CANCELLED');

  private constructor(private readonly value: string) {}

  public canTransitionTo(newStatus: OrderStatus): boolean {
    const validTransitions: Record<string, string[]> = {
      'PENDING': ['CONFIRMED', 'CANCELLED'],
      'CONFIRMED': ['SHIPPED', 'CANCELLED'],
      'SHIPPED': ['DELIVERED'],
      'DELIVERED': [],
      'CANCELLED': []
    };

    return validTransitions[this.value]?.includes(newStatus.value) ?? false;
  }

  public equals(other: OrderStatus): boolean {
    return this.value === other.value;
  }
}

// Business rules embedded in domain objects
class OrderItem {
  constructor(
    private readonly productId: ProductId,
    private readonly quantity: Quantity,
    private readonly unitPrice: Money
  ) {}

  public getSubtotal(): Money {
    return new Money(
      this.unitPrice.amount * this.quantity.value,
      this.unitPrice.currency
    );
  }

  public canBeDiscounted(): boolean {
    // Business rule: Only items over $100 can be discounted
    return this.unitPrice.isGreaterThan(new Money(100, Currency.USD));
  }

  public applyDiscount(discountPercentage: number): OrderItem {
    if (!this.canBeDiscounted()) {
      throw new Error('This item cannot be discounted');
    }

    const discountedPrice = new Money(
      this.unitPrice.amount * (1 - discountPercentage / 100),
      this.unitPrice.currency
    );

    return new OrderItem(this.productId, this.quantity, discountedPrice);
  }
}
```

## Tactical Design Patterns

### Aggregates and Aggregate Roots

Design consistency boundaries within your domain:

```typescript
// Order Aggregate Root
class Order {
  private constructor(
    private readonly orderId: OrderId,
    private readonly customerId: CustomerId,
    private items: OrderItem[],
    private status: OrderStatus,
    private readonly createdAt: Date,
    private version: number = 0
  ) {}

  // Factory method to create new orders
  public static create(
    orderId: OrderId,
    customerId: CustomerId,
    items: OrderItem[]
  ): Order {
    if (items.length === 0) {
      throw new Error('Order must have at least one item');
    }

    return new Order(
      orderId,
      customerId,
      items,
      OrderStatus.PENDING,
      new Date(),
      0
    );
  }

  // Business operations
  public addItem(item: OrderItem): void {
    if (this.status !== OrderStatus.PENDING) {
      throw new Error('Cannot modify order after confirmation');
    }

    this.items.push(item);
    this.raiseEvent(new OrderItemAdded(this.orderId, item));
  }

  public removeItem(productId: ProductId): void {
    if (this.status !== OrderStatus.PENDING) {
      throw new Error('Cannot modify order after confirmation');
    }

    const initialLength = this.items.length;
    this.items = this.items.filter(item => !item.productId.equals(productId));

    if (this.items.length === initialLength) {
      throw new Error('Item not found in order');
    }

    if (this.items.length === 0) {
      throw new Error('Order must have at least one item');
    }

    this.raiseEvent(new OrderItemRemoved(this.orderId, productId));
  }

  public confirm(): void {
    if (this.status !== OrderStatus.PENDING) {
      throw new Error('Only pending orders can be confirmed');
    }

    if (this.getTotalAmount().amount === 0) {
      throw new Error('Cannot confirm order with zero total');
    }

    this.status = OrderStatus.CONFIRMED;
    this.version++;
    this.raiseEvent(new OrderConfirmed(this.orderId, this.getTotalAmount()));
  }

  public ship(trackingNumber: TrackingNumber): void {
    if (this.status !== OrderStatus.CONFIRMED) {
      throw new Error('Only confirmed orders can be shipped');
    }

    this.status = OrderStatus.SHIPPED;
    this.version++;
    this.raiseEvent(new OrderShipped(this.orderId, trackingNumber));
  }

  // Getters for read operations
  public getTotalAmount(): Money {
    return this.items.reduce(
      (total, item) => total.add(item.getSubtotal()),
      Money.zero()
    );
  }

  public getItems(): ReadonlyArray<OrderItem> {
    return [...this.items];
  }

  public getStatus(): OrderStatus {
    return this.status;
  }

  // Domain events
  private events: DomainEvent[] = [];

  private raiseEvent(event: DomainEvent): void {
    this.events.push(event);
  }

  public getUncommittedEvents(): ReadonlyArray<DomainEvent> {
    return [...this.events];
  }

  public markEventsAsCommitted(): void {
    this.events = [];
  }
}

// Customer Aggregate Root
class Customer {
  private constructor(
    private readonly customerId: CustomerId,
    private name: CustomerName,
    private email: EmailAddress,
    private creditLimit: Money,
    private orders: OrderId[] = []
  ) {}

  public static create(
    customerId: CustomerId,
    name: CustomerName,
    email: EmailAddress,
    creditLimit: Money
  ): Customer {
    return new Customer(customerId, name, email, creditLimit);
  }

  public changeName(newName: CustomerName): void {
    if (this.name.equals(newName)) {
      return; // No change needed
    }

    this.name = newName;
    this.raiseEvent(new CustomerNameChanged(this.customerId, newName));
  }

  public updateCreditLimit(newLimit: Money): void {
    if (newLimit.isLessThan(Money.zero())) {
      throw new Error('Credit limit cannot be negative');
    }

    const oldLimit = this.creditLimit;
    this.creditLimit = newLimit;
    
    this.raiseEvent(new CustomerCreditLimitUpdated(
      this.customerId,
      oldLimit,
      newLimit
    ));
  }

  public canAfford(amount: Money): boolean {
    return this.creditLimit.isGreaterThanOrEqual(amount);
  }

  // Track customer orders for business intelligence
  public addOrder(orderId: OrderId): void {
    if (this.orders.includes(orderId)) {
      return; // Order already tracked
    }

    this.orders.push(orderId);
    this.raiseEvent(new CustomerOrderAdded(this.customerId, orderId));
  }

  public getOrderHistory(): ReadonlyArray<OrderId> {
    return [...this.orders];
  }
}
```

### Domain Services

Implement domain logic that doesn't belong to a specific entity:

```typescript
// Domain Services for business operations that span multiple aggregates

interface OrderPricingService {
  calculateOrderTotal(order: Order, customer: Customer): Money;
  applyDiscounts(order: Order, customer: Customer): Order;
}

class OrderPricingDomainService implements OrderPricingService {
  constructor(
    private readonly discountPolicy: DiscountPolicy,
    private readonly taxCalculator: TaxCalculator
  ) {}

  public calculateOrderTotal(order: Order, customer: Customer): Money {
    const baseTotal = order.getTotalAmount();
    const discountAmount = this.discountPolicy.calculateDiscount(order, customer);
    const discountedTotal = baseTotal.subtract(discountAmount);
    const taxAmount = this.taxCalculator.calculateTax(discountedTotal, customer.getAddress());
    
    return discountedTotal.add(taxAmount);
  }

  public applyDiscounts(order: Order, customer: Customer): Order {
    const eligibleItems = order.getItems().filter(item => 
      this.discountPolicy.isEligibleForDiscount(item, customer)
    );

    eligibleItems.forEach(item => {
      const discountPercentage = this.discountPolicy.getDiscountPercentage(item, customer);
      if (discountPercentage > 0) {
        order.updateItem(item.applyDiscount(discountPercentage));
      }
    });

    return order;
  }
}

interface InventoryDomainService {
  reserveInventory(orderId: OrderId, items: OrderItem[]): Promise<ReservationResult>;
  releaseInventory(reservationId: ReservationId): Promise<void>;
}

class InventoryDomainService implements InventoryDomainService {
  constructor(
    private readonly inventoryRepository: InventoryRepository,
    private readonly reservationRepository: ReservationRepository
  ) {}

  public async reserveInventory(
    orderId: OrderId, 
    items: OrderItem[]
  ): Promise<ReservationResult> {
    const reservations: Reservation[] = [];
    const failures: ReservationFailure[] = [];

    for (const item of items) {
      try {
        const inventory = await this.inventoryRepository.findByProductId(item.productId);
        
        if (!inventory) {
          failures.push(new ReservationFailure(
            item.productId,
            'Product not found in inventory'
          ));
          continue;
        }

        if (!inventory.canReserve(item.quantity)) {
          failures.push(new ReservationFailure(
            item.productId,
            `Insufficient stock: available ${inventory.availableQuantity}, requested ${item.quantity}`
          ));
          continue;
        }

        const reservation = inventory.reserve(item.quantity, orderId);
        await this.reservationRepository.save(reservation);
        await this.inventoryRepository.save(inventory);
        
        reservations.push(reservation);
      } catch (error) {
        failures.push(new ReservationFailure(
          item.productId,
          `Reservation failed: ${error.message}`
        ));
      }
    }

    if (failures.length > 0) {
      // Rollback successful reservations
      for (const reservation of reservations) {
        await this.releaseInventory(reservation.reservationId);
      }
      
      return ReservationResult.failure(failures);
    }

    return ReservationResult.success(reservations);
  }

  public async releaseInventory(reservationId: ReservationId): Promise<void> {
    const reservation = await this.reservationRepository.findById(reservationId);
    if (!reservation) {
      throw new Error(`Reservation ${reservationId.value} not found`);
    }

    const inventory = await this.inventoryRepository.findByProductId(reservation.productId);
    if (inventory) {
      inventory.releaseReservation(reservation);
      await this.inventoryRepository.save(inventory);
    }

    await this.reservationRepository.delete(reservation);
  }
}

// Discount Policy as a Domain Service
interface DiscountPolicy {
  calculateDiscount(order: Order, customer: Customer): Money;
  isEligibleForDiscount(item: OrderItem, customer: Customer): boolean;
  getDiscountPercentage(item: OrderItem, customer: Customer): number;
}

class CustomerTierDiscountPolicy implements DiscountPolicy {
  public calculateDiscount(order: Order, customer: Customer): Money {
    const customerTier = this.getCustomerTier(customer);
    const baseTotal = order.getTotalAmount();
    
    switch (customerTier) {
      case CustomerTier.BRONZE:
        return baseTotal.multiply(0.05); // 5% discount
      case CustomerTier.SILVER:
        return baseTotal.multiply(0.10); // 10% discount
      case CustomerTier.GOLD:
        return baseTotal.multiply(0.15); // 15% discount
      case CustomerTier.PLATINUM:
        return baseTotal.multiply(0.20); // 20% discount
      default:
        return Money.zero();
    }
  }

  public isEligibleForDiscount(item: OrderItem, customer: Customer): boolean {
    return this.getCustomerTier(customer) !== CustomerTier.NONE 
           && item.getSubtotal().isGreaterThan(new Money(50, Currency.USD));
  }

  public getDiscountPercentage(item: OrderItem, customer: Customer): number {
    if (!this.isEligibleForDiscount(item, customer)) {
      return 0;
    }

    const tier = this.getCustomerTier(customer);
    switch (tier) {
      case CustomerTier.BRONZE: return 5;
      case CustomerTier.SILVER: return 10;
      case CustomerTier.GOLD: return 15;
      case CustomerTier.PLATINUM: return 20;
      default: return 0;
    }
  }

  private getCustomerTier(customer: Customer): CustomerTier {
    const orderHistory = customer.getOrderHistory();
    const totalOrders = orderHistory.length;
    
    if (totalOrders >= 50) return CustomerTier.PLATINUM;
    if (totalOrders >= 25) return CustomerTier.GOLD;
    if (totalOrders >= 10) return CustomerTier.SILVER;
    if (totalOrders >= 5) return CustomerTier.BRONZE;
    
    return CustomerTier.NONE;
  }
}
```

## Implementation Architecture

### Layered Architecture with DDD

Structure your application to support domain-driven design:

```typescript
// Application Layer - Orchestrates domain operations
class OrderApplicationService {
  constructor(
    private readonly orderRepository: OrderRepository,
    private readonly customerRepository: CustomerRepository,
    private readonly inventoryService: InventoryDomainService,
    private readonly pricingService: OrderPricingDomainService,
    private readonly eventPublisher: DomainEventPublisher,
    private readonly unitOfWork: UnitOfWork
  ) {}

  public async createOrder(command: CreateOrderCommand): Promise<OrderId> {
    return await this.unitOfWork.execute(async () => {
      // Validate customer exists
      const customer = await this.customerRepository.findById(command.customerId);
      if (!customer) {
        throw new Error(`Customer ${command.customerId.value} not found`);
      }

      // Create domain order
      const orderId = OrderId.generate();
      const orderItems = command.items.map(item => 
        new OrderItem(item.productId, item.quantity, item.unitPrice)
      );
      
      const order = Order.create(orderId, command.customerId, orderItems);

      // Apply business rules
      const pricedOrder = this.pricingService.applyDiscounts(order, customer);
      const totalAmount = this.pricingService.calculateOrderTotal(pricedOrder, customer);

      if (!customer.canAfford(totalAmount)) {
        throw new Error('Customer credit limit exceeded');
      }

      // Reserve inventory
      const reservationResult = await this.inventoryService.reserveInventory(
        orderId, 
        pricedOrder.getItems()
      );

      if (!reservationResult.isSuccess()) {
        throw new Error(`Inventory reservation failed: ${reservationResult.getFailureReason()}`);
      }

      // Save order
      await this.orderRepository.save(pricedOrder);
      
      // Update customer
      customer.addOrder(orderId);
      await this.customerRepository.save(customer);

      // Publish domain events
      const events = pricedOrder.getUncommittedEvents();
      await this.eventPublisher.publishAll(events);
      pricedOrder.markEventsAsCommitted();

      return orderId;
    });
  }

  public async confirmOrder(command: ConfirmOrderCommand): Promise<void> {
    return await this.unitOfWork.execute(async () => {
      const order = await this.orderRepository.findById(command.orderId);
      if (!order) {
        throw new Error(`Order ${command.orderId.value} not found`);
      }

      // Domain operation
      order.confirm();

      // Save changes
      await this.orderRepository.save(order);

      // Publish events
      const events = order.getUncommittedEvents();
      await this.eventPublisher.publishAll(events);
      order.markEventsAsCommitted();
    });
  }

  public async cancelOrder(command: CancelOrderCommand): Promise<void> {
    return await this.unitOfWork.execute(async () => {
      const order = await this.orderRepository.findById(command.orderId);
      if (!order) {
        throw new Error(`Order ${command.orderId.value} not found`);
      }

      // Domain operation
      order.cancel(command.reason);

      // Release inventory reservations
      const reservations = await this.getOrderReservations(command.orderId);
      for (const reservation of reservations) {
        await this.inventoryService.releaseInventory(reservation.reservationId);
      }

      // Save changes
      await this.orderRepository.save(order);

      // Publish events
      const events = order.getUncommittedEvents();
      await this.eventPublisher.publishAll(events);
      order.markEventsAsCommitted();
    });
  }

  private async getOrderReservations(orderId: OrderId): Promise<Reservation[]> {
    // Implementation to get reservations for an order
    return [];
  }
}

// Infrastructure Layer - Repository implementations
class SqlOrderRepository implements OrderRepository {
  constructor(
    private readonly dbContext: DatabaseContext,
    private readonly orderMapper: OrderMapper
  ) {}

  public async findById(orderId: OrderId): Promise<Order | null> {
    const orderData = await this.dbContext.orders
      .include('orderItems')
      .where('id', orderId.value)
      .first();

    if (!orderData) {
      return null;
    }

    return this.orderMapper.toDomain(orderData);
  }

  public async save(order: Order): Promise<void> {
    const orderData = this.orderMapper.toPersistence(order);
    
    await this.dbContext.transaction(async (trx) => {
      // Upsert order
      await trx('orders')
        .insert(orderData.order)
        .onConflict('id')
        .merge();

      // Delete existing order items
      await trx('order_items')
        .where('order_id', orderData.order.id)
        .delete();

      // Insert updated order items
      if (orderData.orderItems.length > 0) {
        await trx('order_items').insert(orderData.orderItems);
      }
    });
  }

  public async findByCustomerId(customerId: CustomerId): Promise<Order[]> {
    const orderDataList = await this.dbContext.orders
      .include('orderItems')
      .where('customer_id', customerId.value);

    return orderDataList.map(orderData => this.orderMapper.toDomain(orderData));
  }
}

// Domain Event Publisher
interface DomainEventPublisher {
  publish(event: DomainEvent): Promise<void>;
  publishAll(events: DomainEvent[]): Promise<void>;
}

class EventBusDomainEventPublisher implements DomainEventPublisher {
  constructor(private readonly eventBus: EventBus) {}

  public async publish(event: DomainEvent): Promise<void> {
    await this.eventBus.publish(event.eventName, event);
  }

  public async publishAll(events: DomainEvent[]): Promise<void> {
    const publishPromises = events.map(event => this.publish(event));
    await Promise.all(publishPromises);
  }
}
```

### Event Storming Implementation

Collaborative domain modeling technique:

```typescript
// Event Storming Results - Domain Events Discovery

// Order Lifecycle Events
abstract class OrderDomainEvent extends DomainEvent {
  constructor(
    public readonly orderId: OrderId,
    public readonly aggregateVersion: number,
    occurredOn: Date = new Date()
  ) {
    super(occurredOn);
  }
}

class OrderCreated extends OrderDomainEvent {
  public readonly eventName = 'OrderCreated';
  
  constructor(
    orderId: OrderId,
    aggregateVersion: number,
    public readonly customerId: CustomerId,
    public readonly items: OrderItem[],
    public readonly totalAmount: Money
  ) {
    super(orderId, aggregateVersion);
  }
}

class OrderItemAdded extends OrderDomainEvent {
  public readonly eventName = 'OrderItemAdded';
  
  constructor(
    orderId: OrderId,
    aggregateVersion: number,
    public readonly addedItem: OrderItem
  ) {
    super(orderId, aggregateVersion);
  }
}

class OrderConfirmed extends OrderDomainEvent {
  public readonly eventName = 'OrderConfirmed';
  
  constructor(
    orderId: OrderId,
    aggregateVersion: number,
    public readonly finalAmount: Money
  ) {
    super(orderId, aggregateVersion);
  }
}

class OrderShipped extends OrderDomainEvent {
  public readonly eventName = 'OrderShipped';
  
  constructor(
    orderId: OrderId,
    aggregateVersion: number,
    public readonly trackingNumber: TrackingNumber,
    public readonly carrier: Carrier
  ) {
    super(orderId, aggregateVersion);
  }
}

class OrderCancelled extends OrderDomainEvent {
  public readonly eventName = 'OrderCancelled';
  
  constructor(
    orderId: OrderId,
    aggregateVersion: number,
    public readonly reason: string,
    public readonly refundAmount: Money
  ) {
    super(orderId, aggregateVersion);
  }
}

// Inventory Events
class InventoryReserved extends DomainEvent {
  public readonly eventName = 'InventoryReserved';
  
  constructor(
    public readonly productId: ProductId,
    public readonly quantity: Quantity,
    public readonly reservationId: ReservationId,
    public readonly orderId: OrderId
  ) {
    super();
  }
}

class InventoryReleased extends DomainEvent {
  public readonly eventName = 'InventoryReleased';
  
  constructor(
    public readonly productId: ProductId,
    public readonly quantity: Quantity,
    public readonly reservationId: ReservationId
  ) {
    super();
  }
}

// Customer Events
class CustomerRegistered extends DomainEvent {
  public readonly eventName = 'CustomerRegistered';
  
  constructor(
    public readonly customerId: CustomerId,
    public readonly name: CustomerName,
    public readonly email: EmailAddress
  ) {
    super();
  }
}

class CustomerCreditLimitUpdated extends DomainEvent {
  public readonly eventName = 'CustomerCreditLimitUpdated';
  
  constructor(
    public readonly customerId: CustomerId,
    public readonly oldLimit: Money,
    public readonly newLimit: Money
  ) {
    super();
  }
}

// Payment Events
class PaymentProcessed extends DomainEvent {
  public readonly eventName = 'PaymentProcessed';
  
  constructor(
    public readonly paymentId: PaymentId,
    public readonly orderId: OrderId,
    public readonly amount: Money,
    public readonly paymentMethod: PaymentMethod
  ) {
    super();
  }
}

class PaymentFailed extends DomainEvent {
  public readonly eventName = 'PaymentFailed';
  
  constructor(
    public readonly paymentId: PaymentId,
    public readonly orderId: OrderId,
    public readonly amount: Money,
    public readonly failureReason: string
  ) {
    super();
  }
}

// Event Handlers for Integration
class OrderEventHandlers {
  constructor(
    private readonly inventoryService: InventoryDomainService,
    private readonly paymentService: PaymentService,
    private readonly shippingService: ShippingService,
    private readonly notificationService: NotificationService
  ) {}

  @EventHandler('OrderCreated')
  public async handleOrderCreated(event: OrderCreated): Promise<void> {
    // Reserve inventory when order is created
    await this.inventoryService.reserveInventory(event.orderId, event.items);
    
    // Send order confirmation notification
    await this.notificationService.sendOrderConfirmation(
      event.customerId,
      event.orderId
    );
  }

  @EventHandler('OrderConfirmed')
  public async handleOrderConfirmed(event: OrderConfirmed): Promise<void> {
    // Process payment when order is confirmed
    await this.paymentService.processPayment(
      event.orderId,
      event.finalAmount
    );
  }

  @EventHandler('PaymentProcessed')
  public async handlePaymentProcessed(event: PaymentProcessed): Promise<void> {
    // Create shipment when payment is successful
    await this.shippingService.createShipment(event.orderId);
    
    // Notify customer of payment confirmation
    await this.notificationService.sendPaymentConfirmation(
      event.orderId,
      event.amount
    );
  }

  @EventHandler('OrderShipped')
  public async handleOrderShipped(event: OrderShipped): Promise<void> {
    // Send tracking notification
    await this.notificationService.sendShippingNotification(
      event.orderId,
      event.trackingNumber,
      event.carrier
    );
  }

  @EventHandler('OrderCancelled')
  public async handleOrderCancelled(event: OrderCancelled): Promise<void> {
    // Release inventory reservations
    await this.inventoryService.releaseInventoryForOrder(event.orderId);
    
    // Process refund if payment was made
    if (event.refundAmount.isGreaterThan(Money.zero())) {
      await this.paymentService.processRefund(event.orderId, event.refundAmount);
    }
    
    // Notify customer of cancellation
    await this.notificationService.sendCancellationNotification(
      event.orderId,
      event.reason
    );
  }
}
```

## Testing Domain Models

### Unit Testing Aggregates

```typescript
// Domain Model Unit Tests
describe('Order Aggregate', () => {
  let orderId: OrderId;
  let customerId: CustomerId;
  let orderItems: OrderItem[];

  beforeEach(() => {
    orderId = OrderId.generate();
    customerId = CustomerId.generate();
    orderItems = [
      new OrderItem(
        ProductId.create('PROD-001'),
        Quantity.create(2),
        Money.create(25.99, Currency.USD)
      ),
      new OrderItem(
        ProductId.create('PROD-002'),
        Quantity.create(1),
        Money.create(15.50, Currency.USD)
      )
    ];
  });

  describe('Order Creation', () => {
    it('should create order with valid data', () => {
      const order = Order.create(orderId, customerId, orderItems);

      expect(order.orderId).toEqual(orderId);
      expect(order.customerId).toEqual(customerId);
      expect(order.getItems()).toHaveLength(2);
      expect(order.getStatus()).toEqual(OrderStatus.PENDING);
      expect(order.getTotalAmount()).toEqual(Money.create(67.48, Currency.USD));
    });

    it('should not create order with empty items', () => {
      expect(() => {
        Order.create(orderId, customerId, []);
      }).toThrow('Order must have at least one item');
    });

    it('should raise OrderCreated event', () => {
      const order = Order.create(orderId, customerId, orderItems);
      const events = order.getUncommittedEvents();

      expect(events).toHaveLength(1);
      expect(events[0]).toBeInstanceOf(OrderCreated);
      expect((events[0] as OrderCreated).orderId).toEqual(orderId);
    });
  });

  describe('Order Modification', () => {
    let order: Order;

    beforeEach(() => {
      order = Order.create(orderId, customerId, orderItems);
      order.markEventsAsCommitted(); // Clear creation events
    });

    it('should add item to pending order', () => {
      const newItem = new OrderItem(
        ProductId.create('PROD-003'),
        Quantity.create(1),
        Money.create(10.00, Currency.USD)
      );

      order.addItem(newItem);

      expect(order.getItems()).toHaveLength(3);
      expect(order.getTotalAmount()).toEqual(Money.create(77.48, Currency.USD));

      const events = order.getUncommittedEvents();
      expect(events).toHaveLength(1);
      expect(events[0]).toBeInstanceOf(OrderItemAdded);
    });

    it('should not add item to confirmed order', () => {
      order.confirm();
      order.markEventsAsCommitted();

      const newItem = new OrderItem(
        ProductId.create('PROD-003'),
        Quantity.create(1),
        Money.create(10.00, Currency.USD)
      );

      expect(() => {
        order.addItem(newItem);
      }).toThrow('Cannot modify order after confirmation');
    });

    it('should remove item from pending order', () => {
      const productIdToRemove = ProductId.create('PROD-001');

      order.removeItem(productIdToRemove);

      expect(order.getItems()).toHaveLength(1);
      expect(order.getTotalAmount()).toEqual(Money.create(15.50, Currency.USD));

      const events = order.getUncommittedEvents();
      expect(events).toHaveLength(1);
      expect(events[0]).toBeInstanceOf(OrderItemRemoved);
    });

    it('should not remove last item from order', () => {
      // Remove all but one item
      order.removeItem(ProductId.create('PROD-001'));
      order.markEventsAsCommitted();

      expect(() => {
        order.removeItem(ProductId.create('PROD-002'));
      }).toThrow('Order must have at least one item');
    });
  });

  describe('Order Status Transitions', () => {
    let order: Order;

    beforeEach(() => {
      order = Order.create(orderId, customerId, orderItems);
      order.markEventsAsCommitted();
    });

    it('should confirm pending order', () => {
      order.confirm();

      expect(order.getStatus()).toEqual(OrderStatus.CONFIRMED);

      const events = order.getUncommittedEvents();
      expect(events).toHaveLength(1);
      expect(events[0]).toBeInstanceOf(OrderConfirmed);
    });

    it('should not confirm already confirmed order', () => {
      order.confirm();
      order.markEventsAsCommitted();

      expect(() => {
        order.confirm();
      }).toThrow('Only pending orders can be confirmed');
    });

    it('should ship confirmed order', () => {
      order.confirm();
      order.markEventsAsCommitted();

      const trackingNumber = TrackingNumber.create('TRACK-123456');
      order.ship(trackingNumber);

      expect(order.getStatus()).toEqual(OrderStatus.SHIPPED);

      const events = order.getUncommittedEvents();
      expect(events).toHaveLength(1);
      expect(events[0]).toBeInstanceOf(OrderShipped);
    });

    it('should not ship pending order', () => {
      const trackingNumber = TrackingNumber.create('TRACK-123456');

      expect(() => {
        order.ship(trackingNumber);
      }).toThrow('Only confirmed orders can be shipped');
    });
  });

  describe('Business Rules', () => {
    it('should not confirm order with zero total', () => {
      // Create order with zero-priced items
      const zeroItems = [
        new OrderItem(
          ProductId.create('FREE-001'),
          Quantity.create(1),
          Money.create(0, Currency.USD)
        )
      ];
      
      const order = Order.create(orderId, customerId, zeroItems);

      expect(() => {
        order.confirm();
      }).toThrow('Cannot confirm order with zero total');
    });

    it('should calculate correct total amount', () => {
      const order = Order.create(orderId, customerId, orderItems);
      
      // 2 * $25.99 + 1 * $15.50 = $67.48
      const expectedTotal = Money.create(67.48, Currency.USD);
      expect(order.getTotalAmount()).toEqual(expectedTotal);
    });
  });
});

// Domain Service Tests
describe('OrderPricingDomainService', () => {
  let pricingService: OrderPricingDomainService;
  let mockDiscountPolicy: jest.Mocked<DiscountPolicy>;
  let mockTaxCalculator: jest.Mocked<TaxCalculator>;

  beforeEach(() => {
    mockDiscountPolicy = {
      calculateDiscount: jest.fn(),
      isEligibleForDiscount: jest.fn(),
      getDiscountPercentage: jest.fn()
    };

    mockTaxCalculator = {
      calculateTax: jest.fn()
    };

    pricingService = new OrderPricingDomainService(
      mockDiscountPolicy,
      mockTaxCalculator
    );
  });

  it('should calculate total with discount and tax', async () => {
    const order = createTestOrder();
    const customer = createTestCustomer();
    
    const baseTotal = Money.create(100, Currency.USD);
    const discountAmount = Money.create(10, Currency.USD);
    const taxAmount = Money.create(9, Currency.USD);

    jest.spyOn(order, 'getTotalAmount').mockReturnValue(baseTotal);
    mockDiscountPolicy.calculateDiscount.mockReturnValue(discountAmount);
    mockTaxCalculator.calculateTax.mockReturnValue(taxAmount);

    const result = pricingService.calculateOrderTotal(order, customer);

    expect(result).toEqual(Money.create(99, Currency.USD)); // 100 - 10 + 9
    expect(mockDiscountPolicy.calculateDiscount).toHaveBeenCalledWith(order, customer);
    expect(mockTaxCalculator.calculateTax).toHaveBeenCalledWith(
      Money.create(90, Currency.USD), // discounted total
      customer.getAddress()
    );
  });
});
```

## Our Complete DDD Framework

<GitHubShowcase 
  repo="vimasa-consulting/domain-driven-design-framework"
  description="Explore our comprehensive Domain-Driven Design framework with strategic and tactical patterns, implementation examples, and collaborative modeling techniques used in enterprise systems processing millions of transactions."
/>

## Production DDD Implementation Checklist

Before implementing DDD in production:

- [ ] **Strategic Design**: Bounded contexts identified and mapped
- [ ] **Ubiquitous Language**: Common terminology established across teams
- [ ] **Aggregate Design**: Consistency boundaries clearly defined
- [ ] **Domain Services**: Business logic properly encapsulated
- [ ] **Event Design**: Domain events for integration and auditability
- [ ] **Repository Patterns**: Data access abstracted from domain logic
- [ ] **Application Services**: Orchestration layer implemented
- [ ] **Testing Strategy**: Domain models and services thoroughly tested
- [ ] **Team Alignment**: Developers and domain experts collaborating effectively
- [ ] **Documentation**: Architecture decisions and domain knowledge captured

<Callout type="success">
Organizations implementing DDD report 40% faster feature delivery, 60% reduction in bugs, and 50% improvement in team communication around complex business requirements.
</Callout>

## External Resources for Continued Learning

- **[Domain-Driven Design by Eric Evans](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)**: The foundational book on Domain-Driven Design
- **[Implementing Domain-Driven Design by Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)**: Practical implementation guide for DDD
- **[Microsoft DDD Documentation](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/)**: Microsoft's guide to DDD in microservices
- **[DDD Community](https://dddcommunity.org/)**: Community resources and discussions on DDD
- **[EventStorming](https://www.eventstorming.com/)**: Workshop format for exploring complex business domains

## Conclusion

Domain-Driven Design provides a systematic approach to tackling complex business domains by aligning software design with business complexity. By implementing strategic design patterns, tactical patterns, and collaborative modeling techniques, teams can build maintainable, scalable systems that truly serve business needs.

The key to successful DDD implementation is fostering close collaboration between domain experts and developers, establishing a ubiquitous language, and continuously refining the domain model based on new insights and business evolution.

---

*This guide is part of our comprehensive technical education platform. Explore our [DDD methodology](https://github.com/vimasa-consulting/domain-driven-design-framework) for more production-ready practices.* 